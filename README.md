# Shpora_C_Sharp_2021
Three tasks created by Kontur for the project "Shpora_2021"

1. 
Дан список операций формата

{"OperationId":"guid","Time":"time"}
где

guid — строка с идентификатором операции
time — строка с временем операции и часовым поясом
Необходимо вывести список идентификаторов операций, произошедших в заданный момент времени.

Например:

{"OperationId":"ab933cd2-3b07-4671-98c2-4f5cafdccaf3","Time":"2021-10-15T10:10:10+00:00"}
{"OperationId":"eedbd10a-7b5b-42ce-b2e8-973122eb939d","Time":"2020-01-23T17:25:33+05:00"}
{"OperationId":"08e8fcbe-4e53-45eb-9136-05f8206e7fbf","Time":"2020-12-11T23:15:18-01:00"}
{"OperationId":"a776a222-c3e0-426e-af24-022fd74b5446","Time":"2020-12-12T03:15:18+03:00"}

Для времени "2020-12-12T05:15:18+05:00" необходимо вывести последние 2 операции.


2. 
Есть простая библиотека криптографии: в ней содержатся сертификаты, которыми можно подписывать любые данные и проверять получившуюся подпись.

Интерфейсы библиотеки выглядят так

public interface IStore : IDisposable
{
    IEnumerable<ICertificate> Certificates { get; }
}
public interface ICertificate : IDisposable
{
    IEnumerable<ICertificateParam> CertificateParams { get; }
    byte[] Sign(byte[] data);
    bool Verify(byte[] signature);
}
public interface ICertificateParam
{
    bool Is(string value);
}
В библиотеке есть не более 100 сертификатов, у каждого из которых есть не более 100 параметров. Каждый параметр — уникален, т.е. если сертификат содержит параметр X, то все остальные сертификаты в хранилище его не содержат.

Все перечисления — постоянны (т.е. повторное перечисление вернет те же объекты в том же порядке), однако перечисления работают нестабильно и медленно. Причем перечисление сертификатов примерно в 20 раз медленнее перечисления параметров.

Необходимо написать хэлпер, который по переданному параметру будет находить сертификат и создавать или верифицировать подпись. При этом стоит минимизировать число запросов к библиотеке, отдавая приоритет перечислению параметров (т.е. не получать сертификат до тех пор, пока нет уверенности, что среди уже полученных нет искомого). Хэлпер должен быть стабильным: если библиотека выдала ошибку при перечислении, он должен ее прокинуть выше, а при следующем вызове быть готовым снова искать, в том числе по еще не раскрытым сертификатам и параметрам.

Если сертификата с переданным параметром нет в библиотеке — необходимо выбросить Exception.

Также из-за нестабильности библиотеки не допускается использование многопоточного кода.


3. 
Как устроена эта задача?
Она разделена на три подзадачи, каждая последующая включает в себя предыдущие. Поэтому code-review будем проводить самой полной подзадачи (сдашь первую и вторую — проверим вторую и засчитаем обе; сдашь только третью — проверим ее и засчитаем сразу все).

Формулировка
Нужно написать парсер математических выражений, содержащих случайные величины.

Нужно скачать проект RandomVariable и реализовать RandomVariableStatisticCalculator. Его единственный метод принимает строку, описывающую случайную величину, и набор видов статистик, которые нужно вычислить.

Строка представляет собой корректное математическое выражение, состоящие из унарных (+-) и бинарных (+-*/) операторов, скобок и операндов — чисел и случайных величин. Числа могут записываться как в целой форме (2), так и в виде десятичной дроби (1.5). Стоит рассматривать любое число как дробное (double), т.е. выражение 3/2 должно давать в результате 1.5, а не 1.

Случайные величины будут записываться в стандартной D&D нотации: XdY (например: 1d20, 2d6, 1d3), где X и Y — целые положительные числа. XdY фактически означает "взять X Y-гранных костей, бросить их и взять сумму".

Уточним, что X и Y не могут быть дробными числами, выражениями или случайными величинами; только целыми положительными числами от 1 до 100. Также зафиксируем, что между двумя случайными величинами допустимы только сложения и вычитания.

Т.е. выражение 5 * (1d20 + 4) / 7 + 1d6 — допустимо, а 1d20 * 2d6 или 1d3 / (4 + 2d20) — нет.

Требования
1. Декомпозиция
2. Код необходимо логично разделить по классам и методам. Обратити внимание, что решения без декомпозиции не пройдут ревью. Так что смело строй архитектуру и пакуй весь проект уже знакомым csharp-packer в UserCode.cs: именно его содержимое и нужно отправить на проверку.
3. Эффективность
4. Код должен быть асимптотически эффективен. Не стоит заменять LINQ на foreach, а заменить экспоненциальный алгоритм на полиномиальный — стоит.
5. Корректность
6. Код должен корректно работать не только на тех тестах, которые есть на ulearn или в примерах.

3.1 В рамках данного задания необходимо уметь вычислять только один вид статистики: матожидание дискретной случайной величины. При этом вычислять нужно эффективно — мы ожидаем алгоритм сложности O(n).

Входная строка	ExpectedValue
2+2*2 ->	6
1d20 ->	10.5
2d6+(-1d12/5) ->	5.7
(1d12+2d6)/2 ->	6.75
3/2.1+100d100-4d8+1d4 ->	5035.928571428572

3.2 Теперь помимо матожидания требуется еще уметь вычислять дисперсию дискретной случайной величины. И мы всё ещё ожидаем, что сложность алгоритма будет O(n).
Входная строка	ExpectedValue	Variance
2+2*2 ->	6 ->	0
1d20 ->	10.5 ->	33.25
2d6+(-1d12/5) ->	5.7 ->	6.31
(1d12+2d6)/2 ->	6.75 ->	4.4375
3/2.1+100d100-4d8+1d4 ->	5035.928571428572 ->	83347.25

3.3 Теперь помимо матожидания и дисперсии необходимо уметь рассчитывать и функцию плотности распределения дискретной случайной величины (f).

Алгоритмически задача рассчёта функции f более сложная, поэтому не будем ограничивать сложностью алгоритма при её рассчёте (однако очевидно неоптимальные решения присылать не стоит). Но помни, что ваш код всё ещё должен уметь рассчиывать матожидание и дисперсию за O(n).

Входная строка	f (задана словарем [ключ] = значение)
1d4 -> 	[1] = 0.25, [2] = 0.25, [3] = 0.25, [4] = 0.25
